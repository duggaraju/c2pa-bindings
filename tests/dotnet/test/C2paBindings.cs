// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace C2pa.Bindings
{
    public enum SeekMode
    {
        Start = 0,
        End = 1,
        Current = 2
    }

    /// <summary>Defines a callback to sign data</summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate long SignerCallback(byte* data, ulong len, byte* signature, long sig_max_size);

    /// <summary>Defines the configuration for a Signer</summary>
    /// <remarks>
    /// <para># Example</para>
    /// <para>```</para>
    /// <para>use c2pa::SignerConfig;</para>
    /// <para>let config = SignerConfig {</para>
    /// <para>alg: &quot;Rs256&quot;.to_string(),</para>
    /// <para>certs: vec![vec![0; 10]],</para>
    /// <para>time_authority_url: Some(&quot;http://example.com&quot;.to_string()),</para>
    /// <para>use_ocsp: true,</para>
    /// <para>};</para>
    /// </remarks>
    /// <summary>An Opaque struct to hold a context value for the stream callbacks</summary>
    /// <summary>Defines a callback to read from a stream</summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate long ReadCallback(__IntPtr context, byte* data, ulong len);

    /// <summary>Defines a callback to seek to an offset in a stream</summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate int SeekCallback(__IntPtr context, int offset, global::C2pa.Bindings.SeekMode mode);

    /// <summary>Defines a callback to write to a stream</summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate long WriteCallback(__IntPtr context, byte* data, ulong len);

    /// <summary>A C2paStream is a Rust Read/Write/Seek stream that can be used in C</summary>
    /// <summary>
    /// <para>Configuration settings for the ManifestBuilder</para>
    /// <para>this is mostly a placeholder for future expansion</para>
    /// </summary>
    public unsafe partial class C2paSigner
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::C2pa.Bindings.C2paSigner> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::C2pa.Bindings.C2paSigner>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::C2pa.Bindings.C2paSigner managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::C2pa.Bindings.C2paSigner managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static C2paSigner __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new C2paSigner(native.ToPointer(), skipVTables);
        }

        internal static C2paSigner __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (C2paSigner)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static C2paSigner __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new C2paSigner(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private C2paSigner(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected C2paSigner(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class ManifestBuilder
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::C2pa.Bindings.ManifestBuilder> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::C2pa.Bindings.ManifestBuilder>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::C2pa.Bindings.ManifestBuilder managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::C2pa.Bindings.ManifestBuilder managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ManifestBuilder __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new ManifestBuilder(native.ToPointer(), skipVTables);
        }

        internal static ManifestBuilder __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ManifestBuilder)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ManifestBuilder __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ManifestBuilder(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ManifestBuilder(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected ManifestBuilder(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class ManifestStoreReader
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::C2pa.Bindings.ManifestStoreReader> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::C2pa.Bindings.ManifestStoreReader>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::C2pa.Bindings.ManifestStoreReader managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::C2pa.Bindings.ManifestStoreReader managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ManifestStoreReader __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new ManifestStoreReader(native.ToPointer(), skipVTables);
        }

        internal static ManifestStoreReader __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ManifestStoreReader)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ManifestStoreReader __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ManifestStoreReader(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ManifestStoreReader(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected ManifestStoreReader(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    /// <summary>Defines the configuration for a Signer</summary>
    /// <remarks>
    /// <para># Example</para>
    /// <para>```</para>
    /// <para>use c2pa::SignerConfig;</para>
    /// <para>let config = SignerConfig {</para>
    /// <para>alg: &quot;Rs256&quot;.to_string(),</para>
    /// <para>certs: vec![vec![0; 10]],</para>
    /// <para>time_authority_url: Some(&quot;http://example.com&quot;.to_string()),</para>
    /// <para>use_ocsp: true,</para>
    /// <para>};</para>
    /// </remarks>
    public unsafe partial class SignerConfigC : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal __IntPtr alg;
            internal __IntPtr certs;
            internal __IntPtr time_authority_url;
            internal byte use_ocsp;

            [SuppressUnmanagedCodeSecurity, DllImport("C2paBindings", EntryPoint = "??0SignerConfigC@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::C2pa.Bindings.SignerConfigC> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::C2pa.Bindings.SignerConfigC>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::C2pa.Bindings.SignerConfigC managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::C2pa.Bindings.SignerConfigC managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        private bool __alg_OwnsNativeMemory = false;
        private bool __certs_OwnsNativeMemory = false;
        private bool __time_authority_url_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static SignerConfigC __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new SignerConfigC(native.ToPointer(), skipVTables);
        }

        internal static SignerConfigC __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (SignerConfigC)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static SignerConfigC __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SignerConfigC(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SignerConfigC(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected SignerConfigC(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SignerConfigC()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::C2pa.Bindings.SignerConfigC.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public SignerConfigC(global::C2pa.Bindings.SignerConfigC _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::C2pa.Bindings.SignerConfigC.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::C2pa.Bindings.SignerConfigC.__Internal*) __Instance) = *((global::C2pa.Bindings.SignerConfigC.__Internal*) _0.__Instance);
            if (_0.__alg_OwnsNativeMemory)
                this.Alg = _0.Alg;
            if (_0.__certs_OwnsNativeMemory)
                this.Certs = _0.Certs;
            if (_0.__time_authority_url_OwnsNativeMemory)
                this.TimeAuthorityUrl = _0.TimeAuthorityUrl;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__alg_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->alg);
            if (__certs_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->certs);
            if (__time_authority_url_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->time_authority_url);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Returns the algorithm of the Signer.</summary>
        public string Alg
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->alg);
            }

            set
            {
                if (__alg_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->alg);
                __alg_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->alg = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->alg = (__IntPtr) __bytePtr0;
            }
        }

        /// <summary>Returns the certificates as a Vec containing a Vec of DER bytes for each certificate.</summary>
        public string Certs
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->certs);
            }

            set
            {
                if (__certs_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->certs);
                __certs_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->certs = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->certs = (__IntPtr) __bytePtr0;
            }
        }

        /// <summary>URL for time authority to time stamp the signature</summary>
        public string TimeAuthorityUrl
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->time_authority_url);
            }

            set
            {
                if (__time_authority_url_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->time_authority_url);
                __time_authority_url_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->time_authority_url = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->time_authority_url = (__IntPtr) __bytePtr0;
            }
        }

        /// <summary>Try to fetch OCSP response for the signing cert if available</summary>
        public bool UseOcsp
        {
            get
            {
                return ((__Internal*)__Instance)->use_ocsp != 0;
            }

            set
            {
                ((__Internal*)__Instance)->use_ocsp = (byte) (value ? 1 : 0);
            }
        }
    }

    /// <summary>An Opaque struct to hold a context value for the stream callbacks</summary>
    public unsafe partial class StreamContext : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("C2paBindings", EntryPoint = "??0StreamContext@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::C2pa.Bindings.StreamContext> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::C2pa.Bindings.StreamContext>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::C2pa.Bindings.StreamContext managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::C2pa.Bindings.StreamContext managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static StreamContext __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new StreamContext(native.ToPointer(), skipVTables);
        }

        internal static StreamContext __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (StreamContext)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static StreamContext __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new StreamContext(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private StreamContext(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected StreamContext(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public StreamContext()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::C2pa.Bindings.StreamContext.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public StreamContext(global::C2pa.Bindings.StreamContext _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::C2pa.Bindings.StreamContext.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::C2pa.Bindings.StreamContext.__Internal*) __Instance) = *((global::C2pa.Bindings.StreamContext.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }
    }

    /// <summary>A C2paStream is a Rust Read/Write/Seek stream that can be used in C</summary>
    public unsafe partial class C2paStream : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal __IntPtr context;
            internal __IntPtr read_callback;
            internal __IntPtr seek_callback;
            internal __IntPtr write_callback;

            [SuppressUnmanagedCodeSecurity, DllImport("C2paBindings", EntryPoint = "??0C2paStream@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::C2pa.Bindings.C2paStream> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::C2pa.Bindings.C2paStream>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::C2pa.Bindings.C2paStream managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::C2pa.Bindings.C2paStream managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static C2paStream __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new C2paStream(native.ToPointer(), skipVTables);
        }

        internal static C2paStream __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (C2paStream)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static C2paStream __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new C2paStream(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private C2paStream(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected C2paStream(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public C2paStream()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::C2pa.Bindings.C2paStream.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public C2paStream(global::C2pa.Bindings.C2paStream _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::C2pa.Bindings.C2paStream.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::C2pa.Bindings.C2paStream.__Internal*) __Instance) = *((global::C2pa.Bindings.C2paStream.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::C2pa.Bindings.StreamContext Context
        {
            get
            {
                var __result0 = global::C2pa.Bindings.StreamContext.__GetOrCreateInstance(((__Internal*)__Instance)->context, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->context = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::C2pa.Bindings.ReadCallback ReadCallback
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->read_callback;
                return __ptr0 == IntPtr.Zero? null : (global::C2pa.Bindings.ReadCallback) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::C2pa.Bindings.ReadCallback));
            }

            set
            {
                ((__Internal*)__Instance)->read_callback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::C2pa.Bindings.SeekCallback SeekCallback
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->seek_callback;
                return __ptr0 == IntPtr.Zero? null : (global::C2pa.Bindings.SeekCallback) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::C2pa.Bindings.SeekCallback));
            }

            set
            {
                ((__Internal*)__Instance)->seek_callback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::C2pa.Bindings.WriteCallback WriteCallback
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->write_callback;
                return __ptr0 == IntPtr.Zero? null : (global::C2pa.Bindings.WriteCallback) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::C2pa.Bindings.WriteCallback));
            }

            set
            {
                ((__Internal*)__Instance)->write_callback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    /// <summary>
    /// <para>Configuration settings for the ManifestBuilder</para>
    /// <para>this is mostly a placeholder for future expansion</para>
    /// </summary>
    public unsafe partial class ManifestBuilderSettingsC : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr claim_generator;
            internal __IntPtr settings;

            [SuppressUnmanagedCodeSecurity, DllImport("C2paBindings", EntryPoint = "??0ManifestBuilderSettingsC@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::C2pa.Bindings.ManifestBuilderSettingsC> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::C2pa.Bindings.ManifestBuilderSettingsC>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::C2pa.Bindings.ManifestBuilderSettingsC managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::C2pa.Bindings.ManifestBuilderSettingsC managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        private bool __claim_generator_OwnsNativeMemory = false;
        private bool __settings_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static ManifestBuilderSettingsC __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new ManifestBuilderSettingsC(native.ToPointer(), skipVTables);
        }

        internal static ManifestBuilderSettingsC __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ManifestBuilderSettingsC)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ManifestBuilderSettingsC __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ManifestBuilderSettingsC(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ManifestBuilderSettingsC(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected ManifestBuilderSettingsC(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ManifestBuilderSettingsC()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::C2pa.Bindings.ManifestBuilderSettingsC.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ManifestBuilderSettingsC(global::C2pa.Bindings.ManifestBuilderSettingsC _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::C2pa.Bindings.ManifestBuilderSettingsC.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::C2pa.Bindings.ManifestBuilderSettingsC.__Internal*) __Instance) = *((global::C2pa.Bindings.ManifestBuilderSettingsC.__Internal*) _0.__Instance);
            if (_0.__claim_generator_OwnsNativeMemory)
                this.ClaimGenerator = _0.ClaimGenerator;
            if (_0.__settings_OwnsNativeMemory)
                this.Settings = _0.Settings;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__claim_generator_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->claim_generator);
            if (__settings_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->settings);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string ClaimGenerator
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->claim_generator);
            }

            set
            {
                if (__claim_generator_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->claim_generator);
                __claim_generator_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->claim_generator = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->claim_generator = (__IntPtr) __bytePtr0;
            }
        }

        public string Settings
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->settings);
            }

            set
            {
                if (__settings_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->settings);
                __settings_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->settings = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->settings = (__IntPtr) __bytePtr0;
            }
        }
    }

    public unsafe partial class c2pa
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("c2pa_bindings", EntryPoint = "c2pa_create_signer", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr C2paCreateSigner(__IntPtr signer, __IntPtr config);

            [SuppressUnmanagedCodeSecurity, DllImport("c2pa_bindings", EntryPoint = "c2pa_error", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* C2paError();

            [SuppressUnmanagedCodeSecurity, DllImport("c2pa_bindings", EntryPoint = "c2pa_version", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* C2paVersion();

            [SuppressUnmanagedCodeSecurity, DllImport("c2pa_bindings", EntryPoint = "c2pa_supported_extensions", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* C2paSupportedExtensions();

            [SuppressUnmanagedCodeSecurity, DllImport("c2pa_bindings", EntryPoint = "c2pa_create_stream", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr C2paCreateStream(__IntPtr context, __IntPtr read, __IntPtr seek, __IntPtr write);

            [SuppressUnmanagedCodeSecurity, DllImport("c2pa_bindings", EntryPoint = "c2pa_verify_stream", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* C2paVerifyStream(__IntPtr reader);

            [SuppressUnmanagedCodeSecurity, DllImport("c2pa_bindings", EntryPoint = "c2pa_manifest_reader_new", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr C2paManifestReaderNew();

            [SuppressUnmanagedCodeSecurity, DllImport("c2pa_bindings", EntryPoint = "c2pa_manifest_reader_read", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* C2paManifestReaderRead(__IntPtr reader_ptr, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, __IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("c2pa_bindings", EntryPoint = "c2pa_manifest_reader_resource", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void C2paManifestReaderResource(__IntPtr reader_ptr, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string manifest_label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string id, __IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("c2pa_bindings", EntryPoint = "c2pa_create_manifest_builder", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr C2paCreateManifestBuilder(__IntPtr settings, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string json);

            [SuppressUnmanagedCodeSecurity, DllImport("c2pa_bindings", EntryPoint = "c2pa_manifest_builder_sign", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int C2paManifestBuilderSign(__IntPtr builder_ptr, __IntPtr signer, __IntPtr input, __IntPtr output);

            [SuppressUnmanagedCodeSecurity, DllImport("c2pa_bindings", EntryPoint = "c2pa_release_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void C2paReleaseString(sbyte* s);

            [SuppressUnmanagedCodeSecurity, DllImport("c2pa_bindings", EntryPoint = "c2pa_release_stream", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void C2paReleaseStream(__IntPtr stream);

            [SuppressUnmanagedCodeSecurity, DllImport("c2pa_bindings", EntryPoint = "c2pa_release_manifest_reader", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void C2paReleaseManifestReader(__IntPtr reader);

            [SuppressUnmanagedCodeSecurity, DllImport("c2pa_bindings", EntryPoint = "c2pa_release_manifest_builder", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void C2paReleaseManifestBuilder(__IntPtr builder);
        }

        public static global::C2pa.Bindings.C2paSigner C2paCreateSigner(global::C2pa.Bindings.SignerCallback signer, global::C2pa.Bindings.SignerConfigC config)
        {
            var __arg0 = signer == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(signer);
            var __arg1 = config is null ? __IntPtr.Zero : config.__Instance;
            var ___ret = __Internal.C2paCreateSigner(__arg0, __arg1);
            var __result0 = global::C2pa.Bindings.C2paSigner.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Returns the last error message</summary>
        /// <remarks>
        /// <para># Safety</para>
        /// <para>The returned value MUST be released by calling release_string</para>
        /// <para>and it is no longer valid after that call.</para>
        /// </remarks>
        public static sbyte* C2paError()
        {
            var ___ret = __Internal.C2paError();
            return ___ret;
        }

        /// <summary>Returns a version string for logging</summary>
        /// <remarks>
        /// <para># Safety</para>
        /// <para>The returned value MUST be released by calling release_string</para>
        /// <para>and it is no longer valid after that call.</para>
        /// </remarks>
        public static sbyte* C2paVersion()
        {
            var ___ret = __Internal.C2paVersion();
            return ___ret;
        }

        /// <summary>Returns a JSON array of supported file format extensions</summary>
        /// <remarks>
        /// <para># Safety</para>
        /// <para>The returned value MUST be released by calling release_string</para>
        /// <para>and it is no longer valid after that call.</para>
        /// </remarks>
        public static sbyte* C2paSupportedExtensions()
        {
            var ___ret = __Internal.C2paSupportedExtensions();
            return ___ret;
        }

        /// <summary>Creates a new C2paStream from context with callbacks</summary>
        /// <remarks>
        /// <para>This allows implementing streams in other languages</para>
        /// <para># Arguments</para>
        /// <para>* `context` - a pointer to a StreamContext</para>
        /// <para>* `read` - a ReadCallback to read from the stream</para>
        /// <para>* `seek` - a SeekCallback to seek in the stream</para>
        /// <para>* `write` - a WriteCallback to write to the stream</para>
        /// <para># Safety</para>
        /// <para>The context must remain valid for the lifetime of the C2paStream</para>
        /// <para>The resulting C2paStream must be released by calling c2pa_release_stream</para>
        /// </remarks>
        public static global::C2pa.Bindings.C2paStream C2paCreateStream(global::C2pa.Bindings.StreamContext context, global::C2pa.Bindings.ReadCallback read, global::C2pa.Bindings.SeekCallback seek, global::C2pa.Bindings.WriteCallback write)
        {
            var __arg0 = context is null ? __IntPtr.Zero : context.__Instance;
            var __arg1 = read == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(read);
            var __arg2 = seek == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(seek);
            var __arg3 = write == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(write);
            var ___ret = __Internal.C2paCreateStream(__arg0, __arg1, __arg2, __arg3);
            var __result0 = global::C2pa.Bindings.C2paStream.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Verify a stream and return a ManifestStore report</summary>
        /// <remarks>
        /// <para># Errors</para>
        /// <para>Returns an error field if there were errors</para>
        /// <para># Safety</para>
        /// <para>The returned value MUST be released by calling release_string</para>
        /// <para>and it is no longer valid after that call.</para>
        /// </remarks>
        public static sbyte* C2paVerifyStream(global::C2pa.Bindings.C2paStream reader)
        {
            var __arg0 = reader is null ? __IntPtr.Zero : reader.__Instance;
            var ___ret = __Internal.C2paVerifyStream(__arg0);
            return ___ret;
        }

        /// <summary>Create a new ManifestStoreReader</summary>
        /// <remarks>
        /// <para># Safety</para>
        /// <para>The returned value MUST be released by calling release_manifest_reader</para>
        /// <para># Example</para>
        /// <para>```</para>
        /// <para>use c2pa::ManifestStoreReader;</para>
        /// <para>let reader = ManifestStoreReader::new();</para>
        /// <para>```</para>
        /// </remarks>
        public static global::C2pa.Bindings.ManifestStoreReader C2paManifestReaderNew()
        {
            var ___ret = __Internal.C2paManifestReaderNew();
            var __result0 = global::C2pa.Bindings.ManifestStoreReader.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Read a manifest store from a stream</summary>
        /// <remarks>
        /// <para># Arguments</para>
        /// <para>* `reader_ptr` - a pointer to a ManifestStoreReader</para>
        /// <para>* `format` - the format of the manifest store</para>
        /// <para>* `stream` - the stream to read from</para>
        /// <para># Returns</para>
        /// <para>* `Result` - the json representation of the manifest store</para>
        /// <para># Example</para>
        /// <para>```</para>
        /// <para>use c2pa::ManifestStoreReader;</para>
        /// <para>use std::io::Cursor;</para>
        /// <para>let reader = ManifestStoreReader::new();</para>
        /// <para>let mut stream = Cursor::new(&quot;test&quot;.as_bytes());</para>
        /// <para>let json = reader.read(&quot;image/jpeg&quot;,&amp;mutstream);</para>
        /// <para>```</para>
        /// <para># Safety</para>
        /// <para>Reads from null terminated C strings</para>
        /// <para>The returned value MUST be released by calling release_string</para>
        /// <para>and it is no longer valid after that call.</para>
        /// </remarks>
        public static sbyte* C2paManifestReaderRead(global::C2pa.Bindings.ManifestStoreReader reader_ptr, string format, global::C2pa.Bindings.C2paStream stream)
        {
            var ____arg0 = reader_ptr is null ? __IntPtr.Zero : reader_ptr.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            var __arg2 = stream is null ? __IntPtr.Zero : stream.__Instance;
            var ___ret = __Internal.C2paManifestReaderRead(__arg0, format, __arg2);
            return ___ret;
        }

        /// <summary>Writes a resource from the manifest reader to a stream</summary>
        /// <remarks>
        /// <para># Arguments</para>
        /// <para>* `reader_ptr` - a pointer to a ManifestStoreReader</para>
        /// <para>* `manifest_label` - the manifest label</para>
        /// <para>* `id` - the resource id</para>
        /// <para>* `stream` - the stream to write to</para>
        /// <para># Example</para>
        /// <para>```</para>
        /// <para>use c2pa::ManifestStoreReader;</para>
        /// <para>use std::io::Cursor;</para>
        /// <para>let reader = ManifestStoreReader::new();</para>
        /// <para>let mut stream = Cursor::new(&quot;test&quot;.as_bytes());</para>
        /// <para>reader.resource_write(&quot;manifest&quot;, &quot;id&quot;,&amp;mutstream);</para>
        /// <para>```</para>
        /// <para># Safety</para>
        /// <para>Reads from null terminated C strings</para>
        /// <para># Errors</para>
        /// <para>Returns an error field if there were errors</para>
        /// </remarks>
        public static void C2paManifestReaderResource(global::C2pa.Bindings.ManifestStoreReader reader_ptr, string manifest_label, string id, global::C2pa.Bindings.C2paStream stream)
        {
            var ____arg0 = reader_ptr is null ? __IntPtr.Zero : reader_ptr.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            var __arg3 = stream is null ? __IntPtr.Zero : stream.__Instance;
            __Internal.C2paManifestReaderResource(__arg0, manifest_label, id, __arg3);
        }

        /// <summary>Create a ManifestBuilder</summary>
        /// <remarks>
        /// <para># Arguments</para>
        /// <para>* `settings` - a pointer to a ManifestBuilderSettingsC</para>
        /// <para>* `json` - a pointer to a null terminated JSON Manifest Definition</para>
        /// <para># Returns</para>
        /// <para>* `Result&lt;&gt;*mut ManifestBuilder&gt;` - a pointer to a ManifestBuilder</para>
        /// <para># Safety</para>
        /// <para>The returned value MUST be released by calling release_manifest_builder</para>
        /// <para># Example</para>
        /// <para>```</para>
        /// <para>use c2pa::{ManifestBuilder, ManifestBuilderSettings};</para>
        /// <para>let json = r#&quot;{</para>
        /// <para>&quot;claim_generator&quot;: &quot;test_generator&quot;,</para>
        /// <para>&quot;format&quot;: &quot;image/jpeg&quot;,</para>
        /// <para>&quot;title&quot;: &quot;test_title&quot;</para>
        /// <para>}&quot;#;</para>
        /// <para>let settings = ManifestBuilderSettings {</para>
        /// <para>generator: &quot;test&quot;.to_string(),</para>
        /// <para>};</para>
        /// <para>let builder = ManifestBuilder::new(&amp;settings);</para>
        /// <para>builder.from_json(json);</para>
        /// <para>```</para>
        /// </remarks>
        public static global::C2pa.Bindings.ManifestBuilder C2paCreateManifestBuilder(global::C2pa.Bindings.ManifestBuilderSettingsC settings, string json)
        {
            var __arg0 = settings is null ? __IntPtr.Zero : settings.__Instance;
            var ___ret = __Internal.C2paCreateManifestBuilder(__arg0, json);
            var __result0 = global::C2pa.Bindings.ManifestBuilder.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Sign using a ManifestBuilder</summary>
        /// <remarks>
        /// <para># Arguments</para>
        /// <para>* `builder` - a pointer to a ManifestBuilder</para>
        /// <para>* `signer` - a pointer to a C2paSigner</para>
        /// <para>* `input` - a pointer to a C2paStream</para>
        /// <para>* `output` - optional pointer to a C2paStream</para>
        /// </remarks>
        public static int C2paManifestBuilderSign(global::C2pa.Bindings.ManifestBuilder builder_ptr, global::C2pa.Bindings.C2paSigner signer, global::C2pa.Bindings.C2paStream input, global::C2pa.Bindings.C2paStream output)
        {
            var ____arg0 = builder_ptr is null ? __IntPtr.Zero : builder_ptr.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            var __arg1 = signer is null ? __IntPtr.Zero : signer.__Instance;
            var __arg2 = input is null ? __IntPtr.Zero : input.__Instance;
            var __arg3 = output is null ? __IntPtr.Zero : output.__Instance;
            var ___ret = __Internal.C2paManifestBuilderSign(__arg0, __arg1, __arg2, __arg3);
            return ___ret;
        }

        /// <summary>Releases a string allocated by Rust</summary>
        /// <remarks>
        /// <para># Safety</para>
        /// <para>Reads from null terminated C strings</para>
        /// <para>The string must not have been modified in C</para>
        /// <para>can only be released once and is invalid after this call</para>
        /// </remarks>
        public static void C2paReleaseString(sbyte* s)
        {
            __Internal.C2paReleaseString(s);
        }

        /// <summary>Releases a C2paStream allocated by Rust</summary>
        /// <remarks>
        /// <para># Safety</para>
        /// <para>Reads from null terminated C strings</para>
        /// <para>The string must not have been modified in C</para>
        /// <para>can only be released once and is invalid after this call</para>
        /// </remarks>
        public static void C2paReleaseStream(global::C2pa.Bindings.C2paStream stream)
        {
            var __arg0 = stream is null ? __IntPtr.Zero : stream.__Instance;
            __Internal.C2paReleaseStream(__arg0);
        }

        /// <summary>Releases a ManifestStoreReader allocated by Rust</summary>
        /// <remarks>
        /// <para># Safety</para>
        /// <para>can only be released once and is invalid after this call</para>
        /// </remarks>
        public static void C2paReleaseManifestReader(global::C2pa.Bindings.ManifestStoreReader reader)
        {
            var __arg0 = reader is null ? __IntPtr.Zero : reader.__Instance;
            __Internal.C2paReleaseManifestReader(__arg0);
        }

        /// <summary>Releases a ManifestBuilder allocated by Rust</summary>
        /// <remarks>
        /// <para># Safety</para>
        /// <para>can only be released once and is invalid after this call</para>
        /// </remarks>
        public static void C2paReleaseManifestBuilder(global::C2pa.Bindings.ManifestBuilder builder)
        {
            var __arg0 = builder is null ? __IntPtr.Zero : builder.__Instance;
            __Internal.C2paReleaseManifestBuilder(__arg0);
        }
    }
}
