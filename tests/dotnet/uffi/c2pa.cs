// <auto-generated>
//     This file was generated by uniffi-bindgen-cs v0.8.0+v0.25.0
//     See https://github.com/NordSecurity/uniffi-bindgen-cs for more information.
// </auto-generated>

#nullable enable

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;

namespace uniffi.c2pa;

// This is a helper for safely working with byte buffers returned from the Rust code.
// A rust-owned buffer is represented by its capacity, its current length, and a
// pointer to the underlying data.

[StructLayout(LayoutKind.Sequential)]
internal struct RustBuffer
{
    public int capacity;
    public int len;
    public IntPtr data;

    public static RustBuffer Alloc(int size)
    {
        return _UniffiHelpers.RustCall(
            (ref RustCallStatus status) =>
            {
                var buffer = _UniFFILib.ffi_c2pa_bindings_rustbuffer_alloc(size, ref status);
                if (buffer.data == IntPtr.Zero)
                {
                    throw new AllocationException(
                        $"RustBuffer.Alloc() returned null data pointer (size={size})"
                    );
                }
                return buffer;
            }
        );
    }

    public static void Free(RustBuffer buffer)
    {
        _UniffiHelpers.RustCall(
            (ref RustCallStatus status) =>
            {
                _UniFFILib.ffi_c2pa_bindings_rustbuffer_free(buffer, ref status);
            }
        );
    }

    public static BigEndianStream MemoryStream(IntPtr data, int length)
    {
        unsafe
        {
            return new BigEndianStream(new UnmanagedMemoryStream((byte*)data.ToPointer(), length));
        }
    }

    public BigEndianStream AsStream()
    {
        unsafe
        {
            return new BigEndianStream(new UnmanagedMemoryStream((byte*)data.ToPointer(), len));
        }
    }

    public BigEndianStream AsWriteableStream()
    {
        unsafe
        {
            return new BigEndianStream(
                new UnmanagedMemoryStream(
                    (byte*)data.ToPointer(),
                    capacity,
                    capacity,
                    FileAccess.Write
                )
            );
        }
    }
}

// This is a helper for safely passing byte references into the rust code.
// It's not actually used at the moment, because there aren't many things that you
// can take a direct pointer to managed memory, and if we're going to copy something
// then we might as well copy it into a `RustBuffer`. But it's here for API
// completeness.

[StructLayout(LayoutKind.Sequential)]
internal struct ForeignBytes
{
    public int length;
    public IntPtr data;
}

// The FfiConverter interface handles converter types to and from the FFI
//
// All implementing objects should be public to support external types.  When a
// type is external we need to import it's FfiConverter.
internal abstract class FfiConverter<CsType, FfiType>
{
    // Convert an FFI type to a C# type
    public abstract CsType Lift(FfiType value);

    // Convert C# type to an FFI type
    public abstract FfiType Lower(CsType value);

    // Read a C# type from a `ByteBuffer`
    public abstract CsType Read(BigEndianStream stream);

    // Calculate bytes to allocate when creating a `RustBuffer`
    //
    // This must return at least as many bytes as the write() function will
    // write. It can return more bytes than needed, for example when writing
    // Strings we can't know the exact bytes needed until we the UTF-8
    // encoding, so we pessimistically allocate the largest size possible (3
    // bytes per codepoint).  Allocating extra bytes is not really a big deal
    // because the `RustBuffer` is short-lived.
    public abstract int AllocationSize(CsType value);

    // Write a C# type to a `ByteBuffer`
    public abstract void Write(CsType value, BigEndianStream stream);

    // Lower a value into a `RustBuffer`
    //
    // This method lowers a value into a `RustBuffer` rather than the normal
    // FfiType.  It's used by the callback interface code.  Callback interface
    // returns are always serialized into a `RustBuffer` regardless of their
    // normal FFI type.
    public RustBuffer LowerIntoRustBuffer(CsType value)
    {
        var rbuf = RustBuffer.Alloc(AllocationSize(value));
        try
        {
            var stream = rbuf.AsWriteableStream();
            Write(value, stream);
            rbuf.len = Convert.ToInt32(stream.Position);
            return rbuf;
        }
        catch
        {
            RustBuffer.Free(rbuf);
            throw;
        }
    }

    // Lift a value from a `RustBuffer`.
    //
    // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
    // It's currently only used by the `FfiConverterRustBuffer` class below.
    protected CsType LiftFromRustBuffer(RustBuffer rbuf)
    {
        var stream = rbuf.AsStream();
        try
        {
            var item = Read(stream);
            if (stream.HasRemaining())
            {
                throw new InternalException(
                    "junk remaining in buffer after lifting, something is very wrong!!"
                );
            }
            return item;
        }
        finally
        {
            RustBuffer.Free(rbuf);
        }
    }
}

// FfiConverter that uses `RustBuffer` as the FfiType
internal abstract class FfiConverterRustBuffer<CsType> : FfiConverter<CsType, RustBuffer>
{
    public override CsType Lift(RustBuffer value)
    {
        return LiftFromRustBuffer(value);
    }

    public override RustBuffer Lower(CsType value)
    {
        return LowerIntoRustBuffer(value);
    }
}

// A handful of classes and functions to support the generated data structures.
// This would be a good candidate for isolating in its own ffi-support lib.
// Error runtime.
[StructLayout(LayoutKind.Sequential)]
struct RustCallStatus
{
    public sbyte code;
    public RustBuffer error_buf;

    public bool IsSuccess()
    {
        return code == 0;
    }

    public bool IsError()
    {
        return code == 1;
    }

    public bool IsPanic()
    {
        return code == 2;
    }
}

// Base class for all uniffi exceptions
internal class UniffiException : Exception
{
    public UniffiException()
        : base() { }

    public UniffiException(string message)
        : base(message) { }
}

internal class UndeclaredErrorException : UniffiException
{
    public UndeclaredErrorException(string message)
        : base(message) { }
}

internal class PanicException : UniffiException
{
    public PanicException(string message)
        : base(message) { }
}

internal class AllocationException : UniffiException
{
    public AllocationException(string message)
        : base(message) { }
}

internal class InternalException : UniffiException
{
    public InternalException(string message)
        : base(message) { }
}

internal class InvalidEnumException : InternalException
{
    public InvalidEnumException(string message)
        : base(message) { }
}

internal class UniffiContractVersionException : UniffiException
{
    public UniffiContractVersionException(string message)
        : base(message) { }
}

internal class UniffiContractChecksumException : UniffiException
{
    public UniffiContractChecksumException(string message)
        : base(message) { }
}

// Each top-level error class has a companion object that can lift the error from the call status's rust buffer
interface CallStatusErrorHandler<E>
    where E : Exception
{
    E Lift(RustBuffer error_buf);
}

// CallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
class NullCallStatusErrorHandler : CallStatusErrorHandler<UniffiException>
{
    public static NullCallStatusErrorHandler INSTANCE = new NullCallStatusErrorHandler();

    public UniffiException Lift(RustBuffer error_buf)
    {
        RustBuffer.Free(error_buf);
        return new UndeclaredErrorException(
            "library has returned an error not declared in UNIFFI interface file"
        );
    }
}

// Helpers for calling Rust
// In practice we usually need to be synchronized to call this safely, so it doesn't
// synchronize itself
class _UniffiHelpers
{
    public delegate void RustCallAction(ref RustCallStatus status);
    public delegate U RustCallFunc<out U>(ref RustCallStatus status);

    // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
    public static U RustCallWithError<U, E>(
        CallStatusErrorHandler<E> errorHandler,
        RustCallFunc<U> callback
    )
        where E : UniffiException
    {
        var status = new RustCallStatus();
        var return_value = callback(ref status);
        if (status.IsSuccess())
        {
            return return_value;
        }
        else if (status.IsError())
        {
            throw errorHandler.Lift(status.error_buf);
        }
        else if (status.IsPanic())
        {
            // when the rust code sees a panic, it tries to construct a rustbuffer
            // with the message.  but if that code panics, then it just sends back
            // an empty buffer.
            if (status.error_buf.len > 0)
            {
                throw new PanicException(FfiConverterString.INSTANCE.Lift(status.error_buf));
            }
            else
            {
                throw new PanicException("Rust panic");
            }
        }
        else
        {
            throw new InternalException($"Unknown rust call status: {status.code}");
        }
    }

    // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
    public static void RustCallWithError<E>(
        CallStatusErrorHandler<E> errorHandler,
        RustCallAction callback
    )
        where E : UniffiException
    {
        _UniffiHelpers.RustCallWithError(
            errorHandler,
            (ref RustCallStatus status) =>
            {
                callback(ref status);
                return 0;
            }
        );
    }

    // Call a rust function that returns a plain value
    public static U RustCall<U>(RustCallFunc<U> callback)
    {
        return _UniffiHelpers.RustCallWithError(NullCallStatusErrorHandler.INSTANCE, callback);
    }

    // Call a rust function that returns a plain value
    public static void RustCall(RustCallAction callback)
    {
        _UniffiHelpers.RustCall(
            (ref RustCallStatus status) =>
            {
                callback(ref status);
                return 0;
            }
        );
    }
}

// Big endian streams are not yet available in dotnet :'(
// https://github.com/dotnet/runtime/issues/26904

class StreamUnderflowException : Exception
{
    public StreamUnderflowException() { }
}

class BigEndianStream
{
    Stream stream;

    public BigEndianStream(Stream stream)
    {
        this.stream = stream;
    }

    public bool HasRemaining()
    {
        return (stream.Length - stream.Position) > 0;
    }

    public long Position
    {
        get => stream.Position;
        set => stream.Position = value;
    }

    public void WriteBytes(byte[] value)
    {
        stream.Write(value, 0, value.Length);
    }

    public void WriteByte(byte value)
    {
        stream.WriteByte(value);
    }

    public void WriteUShort(ushort value)
    {
        stream.WriteByte((byte)(value >> 8));
        stream.WriteByte((byte)value);
    }

    public void WriteUInt(uint value)
    {
        stream.WriteByte((byte)(value >> 24));
        stream.WriteByte((byte)(value >> 16));
        stream.WriteByte((byte)(value >> 8));
        stream.WriteByte((byte)value);
    }

    public void WriteULong(ulong value)
    {
        WriteUInt((uint)(value >> 32));
        WriteUInt((uint)value);
    }

    public void WriteSByte(sbyte value)
    {
        stream.WriteByte((byte)value);
    }

    public void WriteShort(short value)
    {
        WriteUShort((ushort)value);
    }

    public void WriteInt(int value)
    {
        WriteUInt((uint)value);
    }

    public void WriteFloat(float value)
    {
        unsafe
        {
            WriteInt(*((int*)&value));
        }
    }

    public void WriteLong(long value)
    {
        WriteULong((ulong)value);
    }

    public void WriteDouble(double value)
    {
        WriteLong(BitConverter.DoubleToInt64Bits(value));
    }

    public byte[] ReadBytes(int length)
    {
        CheckRemaining(length);
        byte[] result = new byte[length];
        stream.Read(result, 0, length);
        return result;
    }

    public byte ReadByte()
    {
        CheckRemaining(1);
        return Convert.ToByte(stream.ReadByte());
    }

    public ushort ReadUShort()
    {
        CheckRemaining(2);
        return (ushort)(stream.ReadByte() << 8 | stream.ReadByte());
    }

    public uint ReadUInt()
    {
        CheckRemaining(4);
        return (uint)(
            stream.ReadByte() << 24
            | stream.ReadByte() << 16
            | stream.ReadByte() << 8
            | stream.ReadByte()
        );
    }

    public ulong ReadULong()
    {
        return (ulong)ReadUInt() << 32 | (ulong)ReadUInt();
    }

    public sbyte ReadSByte()
    {
        return (sbyte)ReadByte();
    }

    public short ReadShort()
    {
        return (short)ReadUShort();
    }

    public int ReadInt()
    {
        return (int)ReadUInt();
    }

    public float ReadFloat()
    {
        unsafe
        {
            int value = ReadInt();
            return *((float*)&value);
        }
    }

    public long ReadLong()
    {
        return (long)ReadULong();
    }

    public double ReadDouble()
    {
        return BitConverter.Int64BitsToDouble(ReadLong());
    }

    private void CheckRemaining(int length)
    {
        if (stream.Length - stream.Position < length)
        {
            throw new StreamUnderflowException();
        }
    }
}

// Contains loading, initialization code,
// and the FFI Function declarations in a com.sun.jna.Library.


// This is an implementation detail which will be called internally by the public API.
static class _UniFFILib
{
    static _UniFFILib()
    {
        _UniFFILib.uniffiCheckContractApiVersion();
        _UniFFILib.uniffiCheckApiChecksums();

        FfiConverterTypeSignerCallback.INSTANCE.Register();
        FfiConverterTypeStream.INSTANCE.Register();
    }

    [DllImport("c2pa_bindings")]
    public static extern void uniffi_c2pa_bindings_fn_free_c2pasigner(
        IntPtr ptr,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern C2paSignerSafeHandle uniffi_c2pa_bindings_fn_constructor_c2pasigner_new(
        ulong @callback,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern void uniffi_c2pa_bindings_fn_method_c2pasigner_configure(
        C2paSignerSafeHandle @ptr,
        RustBuffer @config,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern void uniffi_c2pa_bindings_fn_free_manifestbuilder(
        IntPtr ptr,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern ManifestBuilderSafeHandle uniffi_c2pa_bindings_fn_constructor_manifestbuilder_new(
        RustBuffer @settings,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern void uniffi_c2pa_bindings_fn_method_manifestbuilder_from_json(
        ManifestBuilderSafeHandle @ptr,
        RustBuffer @json,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern RustBuffer uniffi_c2pa_bindings_fn_method_manifestbuilder_sign_stream(
        ManifestBuilderSafeHandle @ptr,
        C2paSignerSafeHandle @signer,
        ulong @input,
        ulong @output,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern void uniffi_c2pa_bindings_fn_free_manifeststorereader(
        IntPtr ptr,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern ManifestStoreReaderSafeHandle uniffi_c2pa_bindings_fn_constructor_manifeststorereader_new(
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern RustBuffer uniffi_c2pa_bindings_fn_method_manifeststorereader_json(
        ManifestStoreReaderSafeHandle @ptr,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern RustBuffer uniffi_c2pa_bindings_fn_method_manifeststorereader_read_stream(
        ManifestStoreReaderSafeHandle @ptr,
        RustBuffer @format,
        ulong @reader,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern RustBuffer uniffi_c2pa_bindings_fn_method_manifeststorereader_resource(
        ManifestStoreReaderSafeHandle @ptr,
        RustBuffer @manifest,
        RustBuffer @id,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern void uniffi_c2pa_bindings_fn_method_manifeststorereader_resource_write_stream(
        ManifestStoreReaderSafeHandle @ptr,
        RustBuffer @manifest,
        RustBuffer @id,
        ulong @stream,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern void uniffi_c2pa_bindings_fn_init_callback_signercallback(
        ForeignCallback @callbackStub,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern void uniffi_c2pa_bindings_fn_init_callback_stream(
        ForeignCallback @callbackStub,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern RustBuffer uniffi_c2pa_bindings_fn_func_supported_extensions(
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern RustBuffer uniffi_c2pa_bindings_fn_func_version(
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern RustBuffer ffi_c2pa_bindings_rustbuffer_alloc(
        int @size,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern RustBuffer ffi_c2pa_bindings_rustbuffer_from_bytes(
        ForeignBytes @bytes,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rustbuffer_free(
        RustBuffer @buf,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern RustBuffer ffi_c2pa_bindings_rustbuffer_reserve(
        RustBuffer @buf,
        int @additional,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_continuation_callback_set(
        IntPtr @callback
    );

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_poll_u8(
        IntPtr @handle,
        IntPtr @uniffiCallback
    );

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_cancel_u8(IntPtr @handle);

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_free_u8(IntPtr @handle);

    [DllImport("c2pa_bindings")]
    public static extern byte ffi_c2pa_bindings_rust_future_complete_u8(
        IntPtr @handle,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_poll_i8(
        IntPtr @handle,
        IntPtr @uniffiCallback
    );

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_cancel_i8(IntPtr @handle);

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_free_i8(IntPtr @handle);

    [DllImport("c2pa_bindings")]
    public static extern sbyte ffi_c2pa_bindings_rust_future_complete_i8(
        IntPtr @handle,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_poll_u16(
        IntPtr @handle,
        IntPtr @uniffiCallback
    );

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_cancel_u16(IntPtr @handle);

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_free_u16(IntPtr @handle);

    [DllImport("c2pa_bindings")]
    public static extern ushort ffi_c2pa_bindings_rust_future_complete_u16(
        IntPtr @handle,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_poll_i16(
        IntPtr @handle,
        IntPtr @uniffiCallback
    );

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_cancel_i16(IntPtr @handle);

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_free_i16(IntPtr @handle);

    [DllImport("c2pa_bindings")]
    public static extern short ffi_c2pa_bindings_rust_future_complete_i16(
        IntPtr @handle,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_poll_u32(
        IntPtr @handle,
        IntPtr @uniffiCallback
    );

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_cancel_u32(IntPtr @handle);

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_free_u32(IntPtr @handle);

    [DllImport("c2pa_bindings")]
    public static extern uint ffi_c2pa_bindings_rust_future_complete_u32(
        IntPtr @handle,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_poll_i32(
        IntPtr @handle,
        IntPtr @uniffiCallback
    );

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_cancel_i32(IntPtr @handle);

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_free_i32(IntPtr @handle);

    [DllImport("c2pa_bindings")]
    public static extern int ffi_c2pa_bindings_rust_future_complete_i32(
        IntPtr @handle,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_poll_u64(
        IntPtr @handle,
        IntPtr @uniffiCallback
    );

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_cancel_u64(IntPtr @handle);

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_free_u64(IntPtr @handle);

    [DllImport("c2pa_bindings")]
    public static extern ulong ffi_c2pa_bindings_rust_future_complete_u64(
        IntPtr @handle,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_poll_i64(
        IntPtr @handle,
        IntPtr @uniffiCallback
    );

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_cancel_i64(IntPtr @handle);

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_free_i64(IntPtr @handle);

    [DllImport("c2pa_bindings")]
    public static extern long ffi_c2pa_bindings_rust_future_complete_i64(
        IntPtr @handle,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_poll_f32(
        IntPtr @handle,
        IntPtr @uniffiCallback
    );

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_cancel_f32(IntPtr @handle);

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_free_f32(IntPtr @handle);

    [DllImport("c2pa_bindings")]
    public static extern float ffi_c2pa_bindings_rust_future_complete_f32(
        IntPtr @handle,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_poll_f64(
        IntPtr @handle,
        IntPtr @uniffiCallback
    );

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_cancel_f64(IntPtr @handle);

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_free_f64(IntPtr @handle);

    [DllImport("c2pa_bindings")]
    public static extern double ffi_c2pa_bindings_rust_future_complete_f64(
        IntPtr @handle,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_poll_pointer(
        IntPtr @handle,
        IntPtr @uniffiCallback
    );

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_cancel_pointer(IntPtr @handle);

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_free_pointer(IntPtr @handle);

    [DllImport("c2pa_bindings")]
    public static extern SafeHandle ffi_c2pa_bindings_rust_future_complete_pointer(
        IntPtr @handle,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_poll_rust_buffer(
        IntPtr @handle,
        IntPtr @uniffiCallback
    );

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_cancel_rust_buffer(IntPtr @handle);

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_free_rust_buffer(IntPtr @handle);

    [DllImport("c2pa_bindings")]
    public static extern RustBuffer ffi_c2pa_bindings_rust_future_complete_rust_buffer(
        IntPtr @handle,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_poll_void(
        IntPtr @handle,
        IntPtr @uniffiCallback
    );

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_cancel_void(IntPtr @handle);

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_free_void(IntPtr @handle);

    [DllImport("c2pa_bindings")]
    public static extern void ffi_c2pa_bindings_rust_future_complete_void(
        IntPtr @handle,
        ref RustCallStatus _uniffi_out_err
    );

    [DllImport("c2pa_bindings")]
    public static extern ushort uniffi_c2pa_bindings_checksum_func_supported_extensions();

    [DllImport("c2pa_bindings")]
    public static extern ushort uniffi_c2pa_bindings_checksum_func_version();

    [DllImport("c2pa_bindings")]
    public static extern ushort uniffi_c2pa_bindings_checksum_method_c2pasigner_configure();

    [DllImport("c2pa_bindings")]
    public static extern ushort uniffi_c2pa_bindings_checksum_method_manifestbuilder_from_json();

    [DllImport("c2pa_bindings")]
    public static extern ushort uniffi_c2pa_bindings_checksum_method_manifestbuilder_sign_stream();

    [DllImport("c2pa_bindings")]
    public static extern ushort uniffi_c2pa_bindings_checksum_method_manifeststorereader_json();

    [DllImport("c2pa_bindings")]
    public static extern ushort uniffi_c2pa_bindings_checksum_method_manifeststorereader_read_stream();

    [DllImport("c2pa_bindings")]
    public static extern ushort uniffi_c2pa_bindings_checksum_method_manifeststorereader_resource();

    [DllImport("c2pa_bindings")]
    public static extern ushort uniffi_c2pa_bindings_checksum_method_manifeststorereader_resource_write_stream();

    [DllImport("c2pa_bindings")]
    public static extern ushort uniffi_c2pa_bindings_checksum_constructor_c2pasigner_new();

    [DllImport("c2pa_bindings")]
    public static extern ushort uniffi_c2pa_bindings_checksum_constructor_manifestbuilder_new();

    [DllImport("c2pa_bindings")]
    public static extern ushort uniffi_c2pa_bindings_checksum_constructor_manifeststorereader_new();

    [DllImport("c2pa_bindings")]
    public static extern ushort uniffi_c2pa_bindings_checksum_method_signercallback_sign();

    [DllImport("c2pa_bindings")]
    public static extern ushort uniffi_c2pa_bindings_checksum_method_stream_read_stream();

    [DllImport("c2pa_bindings")]
    public static extern ushort uniffi_c2pa_bindings_checksum_method_stream_seek_stream();

    [DllImport("c2pa_bindings")]
    public static extern ushort uniffi_c2pa_bindings_checksum_method_stream_write_stream();

    [DllImport("c2pa_bindings")]
    public static extern uint ffi_c2pa_bindings_uniffi_contract_version();

    static void uniffiCheckContractApiVersion()
    {
        var scaffolding_contract_version = _UniFFILib.ffi_c2pa_bindings_uniffi_contract_version();
        if (24 != scaffolding_contract_version)
        {
            throw new UniffiContractVersionException(
                $"uniffi.c2pa: uniffi bindings expected version `24`, library returned `{scaffolding_contract_version}`"
            );
        }
    }

    static void uniffiCheckApiChecksums()
    {
        {
            var checksum = _UniFFILib.uniffi_c2pa_bindings_checksum_func_supported_extensions();
            if (checksum != 17836)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.c2pa: uniffi bindings expected function `uniffi_c2pa_bindings_checksum_func_supported_extensions` checksum `17836`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_c2pa_bindings_checksum_func_version();
            if (checksum != 48729)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.c2pa: uniffi bindings expected function `uniffi_c2pa_bindings_checksum_func_version` checksum `48729`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_c2pa_bindings_checksum_method_c2pasigner_configure();
            if (checksum != 47694)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.c2pa: uniffi bindings expected function `uniffi_c2pa_bindings_checksum_method_c2pasigner_configure` checksum `47694`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_c2pa_bindings_checksum_method_manifestbuilder_from_json();
            if (checksum != 25196)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.c2pa: uniffi bindings expected function `uniffi_c2pa_bindings_checksum_method_manifestbuilder_from_json` checksum `25196`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_c2pa_bindings_checksum_method_manifestbuilder_sign_stream();
            if (checksum != 45234)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.c2pa: uniffi bindings expected function `uniffi_c2pa_bindings_checksum_method_manifestbuilder_sign_stream` checksum `45234`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_c2pa_bindings_checksum_method_manifeststorereader_json();
            if (checksum != 7950)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.c2pa: uniffi bindings expected function `uniffi_c2pa_bindings_checksum_method_manifeststorereader_json` checksum `7950`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_c2pa_bindings_checksum_method_manifeststorereader_read_stream();
            if (checksum != 21903)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.c2pa: uniffi bindings expected function `uniffi_c2pa_bindings_checksum_method_manifeststorereader_read_stream` checksum `21903`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_c2pa_bindings_checksum_method_manifeststorereader_resource();
            if (checksum != 24793)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.c2pa: uniffi bindings expected function `uniffi_c2pa_bindings_checksum_method_manifeststorereader_resource` checksum `24793`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_c2pa_bindings_checksum_method_manifeststorereader_resource_write_stream();
            if (checksum != 12681)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.c2pa: uniffi bindings expected function `uniffi_c2pa_bindings_checksum_method_manifeststorereader_resource_write_stream` checksum `12681`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_c2pa_bindings_checksum_constructor_c2pasigner_new();
            if (checksum != 58840)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.c2pa: uniffi bindings expected function `uniffi_c2pa_bindings_checksum_constructor_c2pasigner_new` checksum `58840`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_c2pa_bindings_checksum_constructor_manifestbuilder_new();
            if (checksum != 55886)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.c2pa: uniffi bindings expected function `uniffi_c2pa_bindings_checksum_constructor_manifestbuilder_new` checksum `55886`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum =
                _UniFFILib.uniffi_c2pa_bindings_checksum_constructor_manifeststorereader_new();
            if (checksum != 46400)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.c2pa: uniffi bindings expected function `uniffi_c2pa_bindings_checksum_constructor_manifeststorereader_new` checksum `46400`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_c2pa_bindings_checksum_method_signercallback_sign();
            if (checksum != 36227)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.c2pa: uniffi bindings expected function `uniffi_c2pa_bindings_checksum_method_signercallback_sign` checksum `36227`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_c2pa_bindings_checksum_method_stream_read_stream();
            if (checksum != 10154)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.c2pa: uniffi bindings expected function `uniffi_c2pa_bindings_checksum_method_stream_read_stream` checksum `10154`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_c2pa_bindings_checksum_method_stream_seek_stream();
            if (checksum != 35443)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.c2pa: uniffi bindings expected function `uniffi_c2pa_bindings_checksum_method_stream_seek_stream` checksum `35443`, library returned `{checksum}`"
                );
            }
        }
        {
            var checksum = _UniFFILib.uniffi_c2pa_bindings_checksum_method_stream_write_stream();
            if (checksum != 58868)
            {
                throw new UniffiContractChecksumException(
                    $"uniffi.c2pa: uniffi bindings expected function `uniffi_c2pa_bindings_checksum_method_stream_write_stream` checksum `58868`, library returned `{checksum}`"
                );
            }
        }
    }
}

// Public interface members begin here.

#pragma warning disable 8625




class FfiConverterUInt64 : FfiConverter<ulong, ulong>
{
    public static FfiConverterUInt64 INSTANCE = new FfiConverterUInt64();

    public override ulong Lift(ulong value)
    {
        return value;
    }

    public override ulong Read(BigEndianStream stream)
    {
        return stream.ReadULong();
    }

    public override ulong Lower(ulong value)
    {
        return value;
    }

    public override int AllocationSize(ulong value)
    {
        return 8;
    }

    public override void Write(ulong value, BigEndianStream stream)
    {
        stream.WriteULong(value);
    }
}

class FfiConverterInt64 : FfiConverter<long, long>
{
    public static FfiConverterInt64 INSTANCE = new FfiConverterInt64();

    public override long Lift(long value)
    {
        return value;
    }

    public override long Read(BigEndianStream stream)
    {
        return stream.ReadLong();
    }

    public override long Lower(long value)
    {
        return value;
    }

    public override int AllocationSize(long value)
    {
        return 8;
    }

    public override void Write(long value, BigEndianStream stream)
    {
        stream.WriteLong(value);
    }
}

class FfiConverterBoolean : FfiConverter<bool, sbyte>
{
    public static FfiConverterBoolean INSTANCE = new FfiConverterBoolean();

    public override bool Lift(sbyte value)
    {
        return value != 0;
    }

    public override bool Read(BigEndianStream stream)
    {
        return Lift(stream.ReadSByte());
    }

    public override sbyte Lower(bool value)
    {
        return value ? (sbyte)1 : (sbyte)0;
    }

    public override int AllocationSize(bool value)
    {
        return (sbyte)1;
    }

    public override void Write(bool value, BigEndianStream stream)
    {
        stream.WriteSByte(Lower(value));
    }
}

class FfiConverterString : FfiConverter<string, RustBuffer>
{
    public static FfiConverterString INSTANCE = new FfiConverterString();

    // Note: we don't inherit from FfiConverterRustBuffer, because we use a
    // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
    // store our length and avoid writing it out to the buffer.
    public override string Lift(RustBuffer value)
    {
        try
        {
            var bytes = value.AsStream().ReadBytes(value.len);
            return System.Text.Encoding.UTF8.GetString(bytes);
        }
        finally
        {
            RustBuffer.Free(value);
        }
    }

    public override string Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var bytes = stream.ReadBytes(length);
        return System.Text.Encoding.UTF8.GetString(bytes);
    }

    public override RustBuffer Lower(string value)
    {
        var bytes = System.Text.Encoding.UTF8.GetBytes(value);
        var rbuf = RustBuffer.Alloc(bytes.Length);
        rbuf.AsWriteableStream().WriteBytes(bytes);
        return rbuf;
    }

    // TODO(CS)
    // We aren't sure exactly how many bytes our string will be once it's UTF-8
    // encoded.  Allocate 3 bytes per unicode codepoint which will always be
    // enough.
    public override int AllocationSize(string value)
    {
        const int sizeForLength = 4;
        var sizeForString = value.Length * 3;
        return sizeForLength + sizeForString;
    }

    public override void Write(string value, BigEndianStream stream)
    {
        var bytes = System.Text.Encoding.UTF8.GetBytes(value);
        stream.WriteInt(bytes.Length);
        stream.WriteBytes(bytes);
    }
}

class FfiConverterByteArray : FfiConverterRustBuffer<byte[]>
{
    public static FfiConverterByteArray INSTANCE = new FfiConverterByteArray();

    public override byte[] Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        return stream.ReadBytes(length);
    }

    public override int AllocationSize(byte[] value)
    {
        return 4 + value.Length;
    }

    public override void Write(byte[] value, BigEndianStream stream)
    {
        stream.WriteInt(value.Length);
        stream.WriteBytes(value);
    }
}

// `SafeHandle` implements the semantics outlined below, i.e. its thread safe, and the dispose
// method will only be called once, once all outstanding native calls have completed.
// https://github.com/mozilla/uniffi-rs/blob/0dc031132d9493ca812c3af6e7dd60ad2ea95bf0/uniffi_bindgen/src/bindings/kotlin/templates/ObjectRuntime.kt#L31
// https://learn.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.criticalhandle

internal abstract class FFIObject<THandle> : IDisposable
    where THandle : FFISafeHandle
{
    private THandle handle;

    public FFIObject(THandle handle)
    {
        this.handle = handle;
    }

    public THandle GetHandle()
    {
        return handle;
    }

    public void Dispose()
    {
        handle.Dispose();
    }
}

internal abstract class FFISafeHandle : SafeHandle
{
    public FFISafeHandle()
        : base(new IntPtr(0), true) { }

    public FFISafeHandle(IntPtr pointer)
        : this()
    {
        this.SetHandle(pointer);
    }

    public override bool IsInvalid
    {
        get { return handle.ToInt64() == 0; }
    }

    // TODO(CS) this completely breaks any guarantees offered by SafeHandle.. Extracting
    // raw value from SafeHandle puts responsiblity on the consumer of this function to
    // ensure that SafeHandle outlives the stream, and anyone who might have read the raw
    // value from the stream and are holding onto it. Otherwise, the result might be a use
    // after free, or free while method calls are still in flight.
    //
    // This is also relevant for Kotlin.
    //
    public IntPtr DangerousGetRawFfiValue()
    {
        return handle;
    }
}

static class FFIObjectUtil
{
    public static void DisposeAll(params Object?[] list)
    {
        foreach (var obj in list)
        {
            Dispose(obj);
        }
    }

    // Dispose is implemented by recursive type inspection at runtime. This is because
    // generating correct Dispose calls for recursive complex types, e.g. List<List<int>>
    // is quite cumbersome.
    private static void Dispose(dynamic? obj)
    {
        if (obj == null)
        {
            return;
        }

        if (obj is IDisposable disposable)
        {
            disposable.Dispose();
            return;
        }

        var type = obj.GetType();
        if (type != null)
        {
            if (type.IsGenericType)
            {
                if (type.GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))
                {
                    foreach (var value in obj)
                    {
                        Dispose(value);
                    }
                }
                else if (type.GetGenericTypeDefinition().IsAssignableFrom(typeof(Dictionary<,>)))
                {
                    foreach (var value in obj.Values)
                    {
                        Dispose(value);
                    }
                }
            }
        }
    }
}

internal interface IC2paSigner
{
    /// <exception cref="C2paException"></exception>
    void Configure(SignerConfig @config);
}

internal class C2paSignerSafeHandle : FFISafeHandle
{
    public C2paSignerSafeHandle()
        : base() { }

    public C2paSignerSafeHandle(IntPtr pointer)
        : base(pointer) { }

    protected override bool ReleaseHandle()
    {
        _UniffiHelpers.RustCall(
            (ref RustCallStatus status) =>
            {
                _UniFFILib.uniffi_c2pa_bindings_fn_free_c2pasigner(this.handle, ref status);
            }
        );
        return true;
    }
}

internal class C2paSigner : FFIObject<C2paSignerSafeHandle>, IC2paSigner
{
    public C2paSigner(C2paSignerSafeHandle pointer)
        : base(pointer) { }

    public C2paSigner(SignerCallback @callback)
        : this(
            _UniffiHelpers.RustCall(
                (ref RustCallStatus _status) =>
                    _UniFFILib.uniffi_c2pa_bindings_fn_constructor_c2pasigner_new(
                        FfiConverterTypeSignerCallback.INSTANCE.Lower(@callback),
                        ref _status
                    )
            )
        ) { }

    /// <exception cref="C2paException"></exception>
    public void Configure(SignerConfig @config)
    {
        _UniffiHelpers.RustCallWithError(
            FfiConverterTypeC2paException.INSTANCE,
            (ref RustCallStatus _status) =>
                _UniFFILib.uniffi_c2pa_bindings_fn_method_c2pasigner_configure(
                    this.GetHandle(),
                    FfiConverterTypeSignerConfig.INSTANCE.Lower(@config),
                    ref _status
                )
        );
    }
}

class FfiConverterTypeC2paSigner : FfiConverter<C2paSigner, C2paSignerSafeHandle>
{
    public static FfiConverterTypeC2paSigner INSTANCE = new FfiConverterTypeC2paSigner();

    public override C2paSignerSafeHandle Lower(C2paSigner value)
    {
        return value.GetHandle();
    }

    public override C2paSigner Lift(C2paSignerSafeHandle value)
    {
        return new C2paSigner(value);
    }

    public override C2paSigner Read(BigEndianStream stream)
    {
        return Lift(new C2paSignerSafeHandle(new IntPtr(stream.ReadLong())));
    }

    public override int AllocationSize(C2paSigner value)
    {
        return 8;
    }

    public override void Write(C2paSigner value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).DangerousGetRawFfiValue().ToInt64());
    }
}

internal interface IManifestBuilder
{
    /// <exception cref="C2paException"></exception>
    void FromJson(String @json);

    /// <exception cref="C2paException"></exception>
    byte[] SignStream(C2paSigner @signer, Stream @input, Stream @output);
}

internal class ManifestBuilderSafeHandle : FFISafeHandle
{
    public ManifestBuilderSafeHandle()
        : base() { }

    public ManifestBuilderSafeHandle(IntPtr pointer)
        : base(pointer) { }

    protected override bool ReleaseHandle()
    {
        _UniffiHelpers.RustCall(
            (ref RustCallStatus status) =>
            {
                _UniFFILib.uniffi_c2pa_bindings_fn_free_manifestbuilder(this.handle, ref status);
            }
        );
        return true;
    }
}

internal class ManifestBuilder : FFIObject<ManifestBuilderSafeHandle>, IManifestBuilder
{
    public ManifestBuilder(ManifestBuilderSafeHandle pointer)
        : base(pointer) { }

    public ManifestBuilder(ManifestBuilderSettings @settings)
        : this(
            _UniffiHelpers.RustCall(
                (ref RustCallStatus _status) =>
                    _UniFFILib.uniffi_c2pa_bindings_fn_constructor_manifestbuilder_new(
                        FfiConverterTypeManifestBuilderSettings.INSTANCE.Lower(@settings),
                        ref _status
                    )
            )
        ) { }

    /// <exception cref="C2paException"></exception>
    public void FromJson(String @json)
    {
        _UniffiHelpers.RustCallWithError(
            FfiConverterTypeC2paException.INSTANCE,
            (ref RustCallStatus _status) =>
                _UniFFILib.uniffi_c2pa_bindings_fn_method_manifestbuilder_from_json(
                    this.GetHandle(),
                    FfiConverterString.INSTANCE.Lower(@json),
                    ref _status
                )
        );
    }

    /// <exception cref="C2paException"></exception>
    public byte[] SignStream(C2paSigner @signer, Stream @input, Stream @output)
    {
        return FfiConverterByteArray.INSTANCE.Lift(
            _UniffiHelpers.RustCallWithError(
                FfiConverterTypeC2paException.INSTANCE,
                (ref RustCallStatus _status) =>
                    _UniFFILib.uniffi_c2pa_bindings_fn_method_manifestbuilder_sign_stream(
                        this.GetHandle(),
                        FfiConverterTypeC2paSigner.INSTANCE.Lower(@signer),
                        FfiConverterTypeStream.INSTANCE.Lower(@input),
                        FfiConverterTypeStream.INSTANCE.Lower(@output),
                        ref _status
                    )
            )
        );
    }
}

class FfiConverterTypeManifestBuilder : FfiConverter<ManifestBuilder, ManifestBuilderSafeHandle>
{
    public static FfiConverterTypeManifestBuilder INSTANCE = new FfiConverterTypeManifestBuilder();

    public override ManifestBuilderSafeHandle Lower(ManifestBuilder value)
    {
        return value.GetHandle();
    }

    public override ManifestBuilder Lift(ManifestBuilderSafeHandle value)
    {
        return new ManifestBuilder(value);
    }

    public override ManifestBuilder Read(BigEndianStream stream)
    {
        return Lift(new ManifestBuilderSafeHandle(new IntPtr(stream.ReadLong())));
    }

    public override int AllocationSize(ManifestBuilder value)
    {
        return 8;
    }

    public override void Write(ManifestBuilder value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).DangerousGetRawFfiValue().ToInt64());
    }
}

internal interface IManifestStoreReader
{
    /// <exception cref="StreamException"></exception>
    String Json();

    /// <exception cref="StreamException"></exception>
    String ReadStream(String @format, Stream @reader);

    /// <exception cref="StreamException"></exception>
    byte[] Resource(String @manifest, String @id);

    /// <exception cref="StreamException"></exception>
    void ResourceWriteStream(String @manifest, String @id, Stream @stream);
}

internal class ManifestStoreReaderSafeHandle : FFISafeHandle
{
    public ManifestStoreReaderSafeHandle()
        : base() { }

    public ManifestStoreReaderSafeHandle(IntPtr pointer)
        : base(pointer) { }

    protected override bool ReleaseHandle()
    {
        _UniffiHelpers.RustCall(
            (ref RustCallStatus status) =>
            {
                _UniFFILib.uniffi_c2pa_bindings_fn_free_manifeststorereader(
                    this.handle,
                    ref status
                );
            }
        );
        return true;
    }
}

internal class ManifestStoreReader : FFIObject<ManifestStoreReaderSafeHandle>, IManifestStoreReader
{
    public ManifestStoreReader(ManifestStoreReaderSafeHandle pointer)
        : base(pointer) { }

    public ManifestStoreReader()
        : this(
            _UniffiHelpers.RustCall(
                (ref RustCallStatus _status) =>
                    _UniFFILib.uniffi_c2pa_bindings_fn_constructor_manifeststorereader_new(
                        ref _status
                    )
            )
        ) { }

    /// <exception cref="StreamException"></exception>
    public String Json()
    {
        return FfiConverterString.INSTANCE.Lift(
            _UniffiHelpers.RustCallWithError(
                FfiConverterTypeStreamException.INSTANCE,
                (ref RustCallStatus _status) =>
                    _UniFFILib.uniffi_c2pa_bindings_fn_method_manifeststorereader_json(
                        this.GetHandle(),
                        ref _status
                    )
            )
        );
    }

    /// <exception cref="StreamException"></exception>
    public String ReadStream(String @format, Stream @reader)
    {
        return FfiConverterString.INSTANCE.Lift(
            _UniffiHelpers.RustCallWithError(
                FfiConverterTypeStreamException.INSTANCE,
                (ref RustCallStatus _status) =>
                    _UniFFILib.uniffi_c2pa_bindings_fn_method_manifeststorereader_read_stream(
                        this.GetHandle(),
                        FfiConverterString.INSTANCE.Lower(@format),
                        FfiConverterTypeStream.INSTANCE.Lower(@reader),
                        ref _status
                    )
            )
        );
    }

    /// <exception cref="StreamException"></exception>
    public byte[] Resource(String @manifest, String @id)
    {
        return FfiConverterByteArray.INSTANCE.Lift(
            _UniffiHelpers.RustCallWithError(
                FfiConverterTypeStreamException.INSTANCE,
                (ref RustCallStatus _status) =>
                    _UniFFILib.uniffi_c2pa_bindings_fn_method_manifeststorereader_resource(
                        this.GetHandle(),
                        FfiConverterString.INSTANCE.Lower(@manifest),
                        FfiConverterString.INSTANCE.Lower(@id),
                        ref _status
                    )
            )
        );
    }

    /// <exception cref="StreamException"></exception>
    public void ResourceWriteStream(String @manifest, String @id, Stream @stream)
    {
        _UniffiHelpers.RustCallWithError(
            FfiConverterTypeStreamException.INSTANCE,
            (ref RustCallStatus _status) =>
                _UniFFILib.uniffi_c2pa_bindings_fn_method_manifeststorereader_resource_write_stream(
                    this.GetHandle(),
                    FfiConverterString.INSTANCE.Lower(@manifest),
                    FfiConverterString.INSTANCE.Lower(@id),
                    FfiConverterTypeStream.INSTANCE.Lower(@stream),
                    ref _status
                )
        );
    }
}

class FfiConverterTypeManifestStoreReader
    : FfiConverter<ManifestStoreReader, ManifestStoreReaderSafeHandle>
{
    public static FfiConverterTypeManifestStoreReader INSTANCE =
        new FfiConverterTypeManifestStoreReader();

    public override ManifestStoreReaderSafeHandle Lower(ManifestStoreReader value)
    {
        return value.GetHandle();
    }

    public override ManifestStoreReader Lift(ManifestStoreReaderSafeHandle value)
    {
        return new ManifestStoreReader(value);
    }

    public override ManifestStoreReader Read(BigEndianStream stream)
    {
        return Lift(new ManifestStoreReaderSafeHandle(new IntPtr(stream.ReadLong())));
    }

    public override int AllocationSize(ManifestStoreReader value)
    {
        return 8;
    }

    public override void Write(ManifestStoreReader value, BigEndianStream stream)
    {
        stream.WriteLong(Lower(value).DangerousGetRawFfiValue().ToInt64());
    }
}

internal record ManifestBuilderSettings(String @generator) { }

class FfiConverterTypeManifestBuilderSettings : FfiConverterRustBuffer<ManifestBuilderSettings>
{
    public static FfiConverterTypeManifestBuilderSettings INSTANCE =
        new FfiConverterTypeManifestBuilderSettings();

    public override ManifestBuilderSettings Read(BigEndianStream stream)
    {
        return new ManifestBuilderSettings(@generator: FfiConverterString.INSTANCE.Read(stream));
    }

    public override int AllocationSize(ManifestBuilderSettings value)
    {
        return FfiConverterString.INSTANCE.AllocationSize(value.@generator);
    }

    public override void Write(ManifestBuilderSettings value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@generator, stream);
    }
}

internal record SignerConfig(
    String @alg,
    byte[] @certs,
    String? @timeAuthorityUrl = null,
    bool @useOcsp = false
) { }

class FfiConverterTypeSignerConfig : FfiConverterRustBuffer<SignerConfig>
{
    public static FfiConverterTypeSignerConfig INSTANCE = new FfiConverterTypeSignerConfig();

    public override SignerConfig Read(BigEndianStream stream)
    {
        return new SignerConfig(
            @alg: FfiConverterString.INSTANCE.Read(stream),
            @certs: FfiConverterByteArray.INSTANCE.Read(stream),
            @timeAuthorityUrl: FfiConverterOptionalString.INSTANCE.Read(stream),
            @useOcsp: FfiConverterBoolean.INSTANCE.Read(stream)
        );
    }

    public override int AllocationSize(SignerConfig value)
    {
        return FfiConverterString.INSTANCE.AllocationSize(value.@alg)
            + FfiConverterByteArray.INSTANCE.AllocationSize(value.@certs)
            + FfiConverterOptionalString.INSTANCE.AllocationSize(value.@timeAuthorityUrl)
            + FfiConverterBoolean.INSTANCE.AllocationSize(value.@useOcsp);
    }

    public override void Write(SignerConfig value, BigEndianStream stream)
    {
        FfiConverterString.INSTANCE.Write(value.@alg, stream);
        FfiConverterByteArray.INSTANCE.Write(value.@certs, stream);
        FfiConverterOptionalString.INSTANCE.Write(value.@timeAuthorityUrl, stream);
        FfiConverterBoolean.INSTANCE.Write(value.@useOcsp, stream);
    }
}

internal class C2paException : UniffiException
{
    C2paException(string message)
        : base(message) { }

    // Each variant is a nested class
    // Flat enums carries a string error message, so no special implementation is necessary.

    public class Assertion : C2paException
    {
        public Assertion(string message)
            : base(message) { }
    }

    public class AssertionNotFound : C2paException
    {
        public AssertionNotFound(string message)
            : base(message) { }
    }

    public class Decoding : C2paException
    {
        public Decoding(string message)
            : base(message) { }
    }

    public class Encoding : C2paException
    {
        public Encoding(string message)
            : base(message) { }
    }

    public class FileNotFound : C2paException
    {
        public FileNotFound(string message)
            : base(message) { }
    }

    public class Io : C2paException
    {
        public Io(string message)
            : base(message) { }
    }

    public class Json : C2paException
    {
        public Json(string message)
            : base(message) { }
    }

    public class Manifest : C2paException
    {
        public Manifest(string message)
            : base(message) { }
    }

    public class ManifestNotFound : C2paException
    {
        public ManifestNotFound(string message)
            : base(message) { }
    }

    public class NotSupported : C2paException
    {
        public NotSupported(string message)
            : base(message) { }
    }

    public class Other : C2paException
    {
        public Other(string message)
            : base(message) { }
    }

    public class NullParameter : C2paException
    {
        public NullParameter(string message)
            : base(message) { }
    }

    public class RemoteManifest : C2paException
    {
        public RemoteManifest(string message)
            : base(message) { }
    }

    public class ResourceNotFound : C2paException
    {
        public ResourceNotFound(string message)
            : base(message) { }
    }

    public class RwLock : C2paException
    {
        public RwLock(string message)
            : base(message) { }
    }

    public class Signature : C2paException
    {
        public Signature(string message)
            : base(message) { }
    }

    public class Verify : C2paException
    {
        public Verify(string message)
            : base(message) { }
    }
}

class FfiConverterTypeC2paException
    : FfiConverterRustBuffer<C2paException>,
        CallStatusErrorHandler<C2paException>
{
    public static FfiConverterTypeC2paException INSTANCE = new FfiConverterTypeC2paException();

    public override C2paException Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new C2paException.Assertion(FfiConverterString.INSTANCE.Read(stream));
            case 2:
                return new C2paException.AssertionNotFound(
                    FfiConverterString.INSTANCE.Read(stream)
                );
            case 3:
                return new C2paException.Decoding(FfiConverterString.INSTANCE.Read(stream));
            case 4:
                return new C2paException.Encoding(FfiConverterString.INSTANCE.Read(stream));
            case 5:
                return new C2paException.FileNotFound(FfiConverterString.INSTANCE.Read(stream));
            case 6:
                return new C2paException.Io(FfiConverterString.INSTANCE.Read(stream));
            case 7:
                return new C2paException.Json(FfiConverterString.INSTANCE.Read(stream));
            case 8:
                return new C2paException.Manifest(FfiConverterString.INSTANCE.Read(stream));
            case 9:
                return new C2paException.ManifestNotFound(FfiConverterString.INSTANCE.Read(stream));
            case 10:
                return new C2paException.NotSupported(FfiConverterString.INSTANCE.Read(stream));
            case 11:
                return new C2paException.Other(FfiConverterString.INSTANCE.Read(stream));
            case 12:
                return new C2paException.NullParameter(FfiConverterString.INSTANCE.Read(stream));
            case 13:
                return new C2paException.RemoteManifest(FfiConverterString.INSTANCE.Read(stream));
            case 14:
                return new C2paException.ResourceNotFound(FfiConverterString.INSTANCE.Read(stream));
            case 15:
                return new C2paException.RwLock(FfiConverterString.INSTANCE.Read(stream));
            case 16:
                return new C2paException.Signature(FfiConverterString.INSTANCE.Read(stream));
            case 17:
                return new C2paException.Verify(FfiConverterString.INSTANCE.Read(stream));
            default:
                throw new InternalException(
                    String.Format(
                        "invalid error value '{0}' in FfiConverterTypeC2paException.Read()",
                        value
                    )
                );
        }
    }

    public override int AllocationSize(C2paException value)
    {
        return 4 + FfiConverterString.INSTANCE.AllocationSize(value.Message);
    }

    public override void Write(C2paException value, BigEndianStream stream)
    {
        switch (value)
        {
            case C2paException.Assertion:
                stream.WriteInt(1);
                break;
            case C2paException.AssertionNotFound:
                stream.WriteInt(2);
                break;
            case C2paException.Decoding:
                stream.WriteInt(3);
                break;
            case C2paException.Encoding:
                stream.WriteInt(4);
                break;
            case C2paException.FileNotFound:
                stream.WriteInt(5);
                break;
            case C2paException.Io:
                stream.WriteInt(6);
                break;
            case C2paException.Json:
                stream.WriteInt(7);
                break;
            case C2paException.Manifest:
                stream.WriteInt(8);
                break;
            case C2paException.ManifestNotFound:
                stream.WriteInt(9);
                break;
            case C2paException.NotSupported:
                stream.WriteInt(10);
                break;
            case C2paException.Other:
                stream.WriteInt(11);
                break;
            case C2paException.NullParameter:
                stream.WriteInt(12);
                break;
            case C2paException.RemoteManifest:
                stream.WriteInt(13);
                break;
            case C2paException.ResourceNotFound:
                stream.WriteInt(14);
                break;
            case C2paException.RwLock:
                stream.WriteInt(15);
                break;
            case C2paException.Signature:
                stream.WriteInt(16);
                break;
            case C2paException.Verify:
                stream.WriteInt(17);
                break;
            default:
                throw new InternalException(
                    String.Format(
                        "invalid error value '{0}' in FfiConverterTypeC2paException.Write()",
                        value
                    )
                );
        }
    }
}

internal enum SeekMode : int
{
    Start,
    End,
    Current
}

class FfiConverterTypeSeekMode : FfiConverterRustBuffer<SeekMode>
{
    public static FfiConverterTypeSeekMode INSTANCE = new FfiConverterTypeSeekMode();

    public override SeekMode Read(BigEndianStream stream)
    {
        var value = stream.ReadInt() - 1;
        if (Enum.IsDefined(typeof(SeekMode), value))
        {
            return (SeekMode)value;
        }
        else
        {
            throw new InternalException(
                String.Format("invalid enum value '{0}' in FfiConverterTypeSeekMode.Read()", value)
            );
        }
    }

    public override int AllocationSize(SeekMode value)
    {
        return 4;
    }

    public override void Write(SeekMode value, BigEndianStream stream)
    {
        stream.WriteInt((int)value + 1);
    }
}

internal class StreamException : UniffiException
{
    // Each variant is a nested class


    public class Io : StreamException
    {
        // Members
        public String @reason;

        // Constructor
        public Io(String @reason)
        {
            this.@reason = @reason;
        }
    }

    public class Other : StreamException
    {
        // Members
        public String @reason;

        // Constructor
        public Other(String @reason)
        {
            this.@reason = @reason;
        }
    }

    public class InternalStreamException : StreamException { }
}

class FfiConverterTypeStreamException
    : FfiConverterRustBuffer<StreamException>,
        CallStatusErrorHandler<StreamException>
{
    public static FfiConverterTypeStreamException INSTANCE = new FfiConverterTypeStreamException();

    public override StreamException Read(BigEndianStream stream)
    {
        var value = stream.ReadInt();
        switch (value)
        {
            case 1:
                return new StreamException.Io(FfiConverterString.INSTANCE.Read(stream));
            case 2:
                return new StreamException.Other(FfiConverterString.INSTANCE.Read(stream));
            case 3:
                return new StreamException.InternalStreamException();
            default:
                throw new InternalException(
                    String.Format(
                        "invalid error value '{0}' in FfiConverterTypeStreamException.Read()",
                        value
                    )
                );
        }
    }

    public override int AllocationSize(StreamException value)
    {
        switch (value)
        {
            case StreamException.Io variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@reason);
            case StreamException.Other variant_value:
                return 4 + FfiConverterString.INSTANCE.AllocationSize(variant_value.@reason);
            case StreamException.InternalStreamException variant_value:
                return 4;
            default:
                throw new InternalException(
                    String.Format(
                        "invalid error value '{0}' in FfiConverterTypeStreamException.AllocationSize()",
                        value
                    )
                );
        }
    }

    public override void Write(StreamException value, BigEndianStream stream)
    {
        switch (value)
        {
            case StreamException.Io variant_value:
                stream.WriteInt(1);
                FfiConverterString.INSTANCE.Write(variant_value.@reason, stream);
                break;
            case StreamException.Other variant_value:
                stream.WriteInt(2);
                FfiConverterString.INSTANCE.Write(variant_value.@reason, stream);
                break;
            case StreamException.InternalStreamException variant_value:
                stream.WriteInt(3);
                break;
            default:
                throw new InternalException(
                    String.Format(
                        "invalid error value '{0}' in FfiConverterTypeStreamException.Write()",
                        value
                    )
                );
        }
    }
}

static class UniffiCallbackResponseCode
{
    public static int SUCCESS = 0;
    public static int ERROR = 1;
    public static int UNEXPECTED_ERROR = 2;
}

class ConcurrentHandleMap<T>
    where T : notnull
{
    Dictionary<ulong, T> leftMap = new Dictionary<ulong, T>();
    Dictionary<T, ulong> rightMap = new Dictionary<T, ulong>();

    Object lock_ = new Object();
    ulong currentHandle = 0;

    public ulong Insert(T obj)
    {
        lock (lock_)
        {
            ulong existingHandle = 0;
            if (rightMap.TryGetValue(obj, out existingHandle))
            {
                return existingHandle;
            }
            currentHandle += 1;
            leftMap[currentHandle] = obj;
            rightMap[obj] = currentHandle;
            return currentHandle;
        }
    }

    public bool TryGet(ulong handle, out T result)
    {
        // Possible null reference assignment
#pragma warning disable 8601
        return leftMap.TryGetValue(handle, out result);
#pragma warning restore 8601
    }

    public bool Remove(ulong handle)
    {
        return Remove(handle, out T result);
    }

    public bool Remove(ulong handle, out T result)
    {
        lock (lock_)
        {
            // Possible null reference assignment
#pragma warning disable 8601
            if (leftMap.TryGetValue(handle, out result))
            {
#pragma warning restore 8601
                leftMap.Remove(handle);
                rightMap.Remove(result);
                return true;
            }
            else
            {
                return false;
            }
        }
    }
}

[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
internal delegate int ForeignCallback(
    ulong handle,
    uint method,
    IntPtr argsData,
    int argsLength,
    ref RustBuffer outBuf
);

internal abstract class FfiConverterCallbackInterface<CallbackInterface>
    : FfiConverter<CallbackInterface, ulong>
    where CallbackInterface : notnull
{
    ConcurrentHandleMap<CallbackInterface> handleMap = new ConcurrentHandleMap<CallbackInterface>();

    // Registers the foreign callback with the Rust side.
    // This method is generated for each callback interface.
    public abstract void Register();

    public RustBuffer Drop(ulong handle)
    {
        handleMap.Remove(handle);
        return new RustBuffer();
    }

    public override CallbackInterface Lift(ulong handle)
    {
        if (!handleMap.TryGet(handle, out CallbackInterface result))
        {
            throw new InternalException($"No callback in handlemap '{handle}'");
        }
        return result;
    }

    public override CallbackInterface Read(BigEndianStream stream)
    {
        return Lift(stream.ReadULong());
    }

    public override ulong Lower(CallbackInterface value)
    {
        return handleMap.Insert(value);
    }

    public override int AllocationSize(CallbackInterface value)
    {
        return 8;
    }

    public override void Write(CallbackInterface value, BigEndianStream stream)
    {
        stream.WriteULong(Lower(value));
    }
}

internal interface SignerCallback
{
    /// <exception cref="StreamException"></exception>
    byte[] Sign(byte[] @data);
}

// The ForeignCallback that is passed to Rust.
class ForeignCallbackTypeSignerCallback
{
    // This cannot be a static method. Although C# supports implicitly using a static method as a
    // delegate, the behaviour is incorrect for this use case. Using static method as a delegate
    // argument creates an implicit delegate object, that is later going to be collected by GC. Any
    // attempt to invoke a garbage collected delegate results in an error:
    //   > A callback was made on a garbage collected delegate of type 'ForeignCallback::..'
    public static ForeignCallback INSTANCE = (
        ulong handle,
        uint method,
        IntPtr argsData,
        int argsLength,
        ref RustBuffer outBuf
    ) =>
    {
        var cb = FfiConverterTypeSignerCallback.INSTANCE.Lift(handle);
        switch (method)
        {
            case 0:
            {
                // 0 means Rust is done with the callback, and the callback
                // can be dropped by the foreign language.
                FfiConverterTypeSignerCallback.INSTANCE.Drop(handle);
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 0;
            }

            case 1:
            {
                try
                {
                    try
                    {
                        outBuf = InvokeSign(cb, RustBuffer.MemoryStream(argsData, argsLength));
                        return UniffiCallbackResponseCode.SUCCESS;
                    }
                    catch (StreamException e)
                    {
                        outBuf = FfiConverterTypeStreamException.INSTANCE.Lower(e);
                        return UniffiCallbackResponseCode.ERROR;
                    }
                }
                catch (Exception e)
                {
                    // Unexpected error
                    try
                    {
                        // Try to serialize the error into a string
                        outBuf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch
                    {
                        // If that fails, then it's time to give up and just return
                    }
                    return UniffiCallbackResponseCode.UNEXPECTED_ERROR;
                }
            }

            default:
            {
                // This should never happen, because an out of bounds method index won't
                // ever be used. Once we can catch errors, we should return an InternalException.
                // https://github.com/mozilla/uniffi-rs/issues/351
                return UniffiCallbackResponseCode.UNEXPECTED_ERROR;
            }
        }
    };

    static RustBuffer InvokeSign(SignerCallback callback, BigEndianStream stream)
    {
        var result = callback.Sign(FfiConverterByteArray.INSTANCE.Read(stream));
        return FfiConverterByteArray.INSTANCE.LowerIntoRustBuffer(result);
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeSignerCallback : FfiConverterCallbackInterface<SignerCallback>
{
    public static FfiConverterTypeSignerCallback INSTANCE = new FfiConverterTypeSignerCallback();

    public override void Register()
    {
        _UniffiHelpers.RustCall(
            (ref RustCallStatus status) =>
            {
                _UniFFILib.uniffi_c2pa_bindings_fn_init_callback_signercallback(
                    ForeignCallbackTypeSignerCallback.INSTANCE,
                    ref status
                );
            }
        );
    }
}

internal interface Stream
{
    /// <exception cref="StreamException"></exception>
    byte[] ReadStream(ulong @length);

    /// <exception cref="StreamException"></exception>
    ulong SeekStream(long @pos, SeekMode @mode);

    /// <exception cref="StreamException"></exception>
    ulong WriteStream(byte[] @data);
}

// The ForeignCallback that is passed to Rust.
class ForeignCallbackTypeStream
{
    // This cannot be a static method. Although C# supports implicitly using a static method as a
    // delegate, the behaviour is incorrect for this use case. Using static method as a delegate
    // argument creates an implicit delegate object, that is later going to be collected by GC. Any
    // attempt to invoke a garbage collected delegate results in an error:
    //   > A callback was made on a garbage collected delegate of type 'ForeignCallback::..'
    public static ForeignCallback INSTANCE = (
        ulong handle,
        uint method,
        IntPtr argsData,
        int argsLength,
        ref RustBuffer outBuf
    ) =>
    {
        var cb = FfiConverterTypeStream.INSTANCE.Lift(handle);
        switch (method)
        {
            case 0:
            {
                // 0 means Rust is done with the callback, and the callback
                // can be dropped by the foreign language.
                FfiConverterTypeStream.INSTANCE.Drop(handle);
                // No return value.
                // See docs of ForeignCallback in `uniffi/src/ffi/foreigncallbacks.rs`
                return 0;
            }

            case 1:
            {
                try
                {
                    try
                    {
                        outBuf = InvokeReadStream(
                            cb,
                            RustBuffer.MemoryStream(argsData, argsLength)
                        );
                        return UniffiCallbackResponseCode.SUCCESS;
                    }
                    catch (StreamException e)
                    {
                        outBuf = FfiConverterTypeStreamException.INSTANCE.Lower(e);
                        return UniffiCallbackResponseCode.ERROR;
                    }
                }
                catch (Exception e)
                {
                    // Unexpected error
                    try
                    {
                        // Try to serialize the error into a string
                        outBuf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch
                    {
                        // If that fails, then it's time to give up and just return
                    }
                    return UniffiCallbackResponseCode.UNEXPECTED_ERROR;
                }
            }

            case 2:
            {
                try
                {
                    try
                    {
                        outBuf = InvokeSeekStream(
                            cb,
                            RustBuffer.MemoryStream(argsData, argsLength)
                        );
                        return UniffiCallbackResponseCode.SUCCESS;
                    }
                    catch (StreamException e)
                    {
                        outBuf = FfiConverterTypeStreamException.INSTANCE.Lower(e);
                        return UniffiCallbackResponseCode.ERROR;
                    }
                }
                catch (Exception e)
                {
                    // Unexpected error
                    try
                    {
                        // Try to serialize the error into a string
                        outBuf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch
                    {
                        // If that fails, then it's time to give up and just return
                    }
                    return UniffiCallbackResponseCode.UNEXPECTED_ERROR;
                }
            }

            case 3:
            {
                try
                {
                    try
                    {
                        outBuf = InvokeWriteStream(
                            cb,
                            RustBuffer.MemoryStream(argsData, argsLength)
                        );
                        return UniffiCallbackResponseCode.SUCCESS;
                    }
                    catch (StreamException e)
                    {
                        outBuf = FfiConverterTypeStreamException.INSTANCE.Lower(e);
                        return UniffiCallbackResponseCode.ERROR;
                    }
                }
                catch (Exception e)
                {
                    // Unexpected error
                    try
                    {
                        // Try to serialize the error into a string
                        outBuf = FfiConverterString.INSTANCE.Lower(e.Message);
                    }
                    catch
                    {
                        // If that fails, then it's time to give up and just return
                    }
                    return UniffiCallbackResponseCode.UNEXPECTED_ERROR;
                }
            }

            default:
            {
                // This should never happen, because an out of bounds method index won't
                // ever be used. Once we can catch errors, we should return an InternalException.
                // https://github.com/mozilla/uniffi-rs/issues/351
                return UniffiCallbackResponseCode.UNEXPECTED_ERROR;
            }
        }
    };

    static RustBuffer InvokeReadStream(Stream callback, BigEndianStream stream)
    {
        var result = callback.ReadStream(FfiConverterUInt64.INSTANCE.Read(stream));
        return FfiConverterByteArray.INSTANCE.LowerIntoRustBuffer(result);
    }

    static RustBuffer InvokeSeekStream(Stream callback, BigEndianStream stream)
    {
        var result = callback.SeekStream(
            FfiConverterInt64.INSTANCE.Read(stream),
            FfiConverterTypeSeekMode.INSTANCE.Read(stream)
        );
        return FfiConverterUInt64.INSTANCE.LowerIntoRustBuffer(result);
    }

    static RustBuffer InvokeWriteStream(Stream callback, BigEndianStream stream)
    {
        var result = callback.WriteStream(FfiConverterByteArray.INSTANCE.Read(stream));
        return FfiConverterUInt64.INSTANCE.LowerIntoRustBuffer(result);
    }
}

// The ffiConverter which transforms the Callbacks in to Handles to pass to Rust.
class FfiConverterTypeStream : FfiConverterCallbackInterface<Stream>
{
    public static FfiConverterTypeStream INSTANCE = new FfiConverterTypeStream();

    public override void Register()
    {
        _UniffiHelpers.RustCall(
            (ref RustCallStatus status) =>
            {
                _UniFFILib.uniffi_c2pa_bindings_fn_init_callback_stream(
                    ForeignCallbackTypeStream.INSTANCE,
                    ref status
                );
            }
        );
    }
}

class FfiConverterOptionalString : FfiConverterRustBuffer<String?>
{
    public static FfiConverterOptionalString INSTANCE = new FfiConverterOptionalString();

    public override String? Read(BigEndianStream stream)
    {
        if (stream.ReadByte() == 0)
        {
            return null;
        }
        return FfiConverterString.INSTANCE.Read(stream);
    }

    public override int AllocationSize(String? value)
    {
        if (value == null)
        {
            return 1;
        }
        else
        {
            return 1 + FfiConverterString.INSTANCE.AllocationSize((String)value);
        }
    }

    public override void Write(String? value, BigEndianStream stream)
    {
        if (value == null)
        {
            stream.WriteByte(0);
        }
        else
        {
            stream.WriteByte(1);
            FfiConverterString.INSTANCE.Write((String)value, stream);
        }
    }
}

class FfiConverterSequenceString : FfiConverterRustBuffer<List<String>>
{
    public static FfiConverterSequenceString INSTANCE = new FfiConverterSequenceString();

    public override List<String> Read(BigEndianStream stream)
    {
        var length = stream.ReadInt();
        var result = new List<String>(length);
        for (int i = 0; i < length; i++)
        {
            result.Add(FfiConverterString.INSTANCE.Read(stream));
        }
        return result;
    }

    public override int AllocationSize(List<String> value)
    {
        var sizeForLength = 4;

        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            return sizeForLength;
        }

        var sizeForItems = value
            .Select(item => FfiConverterString.INSTANCE.AllocationSize(item))
            .Sum();
        return sizeForLength + sizeForItems;
    }

    public override void Write(List<String> value, BigEndianStream stream)
    {
        // details/1-empty-list-as-default-method-parameter.md
        if (value == null)
        {
            stream.WriteInt(0);
            return;
        }

        stream.WriteInt(value.Count);
        value.ForEach(item => FfiConverterString.INSTANCE.Write(item, stream));
    }
}
#pragma warning restore 8625
internal static class C2paMethods
{
    public static List<String> SupportedExtensions()
    {
        return FfiConverterSequenceString.INSTANCE.Lift(
            _UniffiHelpers.RustCall(
                (ref RustCallStatus _status) =>
                    _UniFFILib.uniffi_c2pa_bindings_fn_func_supported_extensions(ref _status)
            )
        );
    }

    public static String Version()
    {
        return FfiConverterString.INSTANCE.Lift(
            _UniffiHelpers.RustCall(
                (ref RustCallStatus _status) =>
                    _UniFFILib.uniffi_c2pa_bindings_fn_func_version(ref _status)
            )
        );
    }
}
